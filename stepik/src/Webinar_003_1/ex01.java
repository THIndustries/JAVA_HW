package Webinar_003_1;

public class ex01 {
    public static void main(String[] args) {
    ex0();
    }
    static void ex0() {
        /*
        Даны следующие строки, сравнить их с помощью == и метода equals() класса Object.
        */
        String s1 = "hello";
        String s2 = "hello";
        String s3 = s1;
        String s4 = "h" + "e" + "l" + "l" + "o";
        String s5 = new String("hello");
        String s6 = new String(new char[]{'h', 'e', 'l', 'l', 'o'});
        System.out.print("Через оператор == сравнения: ");
        System.out.println(s1 == s5); // == в данном контескта проверяет равенство ссылок.
/*
У типа String - отдельная комната в куче. Когда мы создали переменную s1 и положили туда значение "hello", под это значение
выделилась память. Но когда мы создали переменную s2 с точно таким же обьектом (в наме случае - одинаковый набор символов),
то новый обьект не создается, потому что String - неизменяемый тип данных. s2 получит ссылку на старый обьект, а не будет
создан новый.
С переменной s4 немного сложнее история. Т.к. String - неизменяемый тип данных, то при каждой конкатинации - создается
новая ячейка в памяти под новый обьект String. Но когда конкатинация закончится, программа проверит, что такой обьект уже
существет, и просто присвоит s4 ссылку на старый обьект. А с обьектами, на которые нет ссылок, займется сборщик мусора и
удалит их. Как сборщик мусора работает - пока не знаю.

А вот переменные s5 и s6 получат новые ссылки, потому что у них создается новый обьект в куче, посредством оператора new.
Оператор new выделит новый участок памяти под обьект именно в куче, где хранятся все остальные ссылочные типы, а не в
вип-комнате String в куче.
 */

        System.out.print("Через метод equals(): ");
        System.out.println(s1.equals(s6));
        /*
Результатом сравнения через equals() в нашем случае везде будет true. equals() сначала проверят, совпадают ссылки и возвразает
true, если совпадают, если нет, то продолжает сравнение, проверяя что хранится в самих обьектах.
         */

        /*
        ВЫвод, всегда сравниваем ссылочные типы данных методом equals() и никогда через ==
         */
    }
}
